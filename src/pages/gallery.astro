---
import Layout from "../layouts/Layout.astro";
import Footer from "../components/Footer.astro";
import fs from "fs";
import path from "path";

const galleryPath = path.join(process.cwd(), "public", "images", "gallery");
let images = [];
try {
  images = fs
    .readdirSync(galleryPath)
    .filter((f) => f.toLowerCase().endsWith(".webp"))
    .sort()
    .reverse(); // reversed order
} catch (e) {
  images = [];
}
---

<Layout />
<section>
  <div class="gallery mt-12">
    {
      images.length ? (
        images.map((img, i) => (
          // use background-image + size classes for more varied masonry
          <figure
            class={`item h-${i % 5}`}
            key={img}
            data-src={`/images/gallery/${img}`}
            data-alt={img.replace(/\.[^/.]+$/, "").replace(/[-_]/g, " ")}
            role="img"
            aria-label={img.replace(/\.[^/.]+$/, "").replace(/[-_]/g, " ")}
          >
            <span class="sr-only">
              {img.replace(/\.[^/.]+$/, "").replace(/[-_]/g, " ")}
            </span>
          </figure>
        ))
      ) : (
        <p>No images found in /public/images/gallery</p>
      )
    }
  </div>
  <div
    class="insta-link bg-[var(--color-dark-blue)] py-6 rounded-lg my-12 max-w-sm mx-auto px-4"
  >
    <p class="text-center text-2xl text-[var(--color-lav)] italic">
      All photos with before and after on{" "}
      <a
        href="https://www.instagram.com/mysticmanesbeauty/"
        target="_blank"
        rel="noopener noreferrer"
        class="underline">Instagram</a
      >
    </p>
  </div>
</section>
<Footer />

<style>
  /* Container */
  section {
    max-width: 1280px;
    margin: 0 auto;
    padding-top: 3rem;
  }

  /*
    Masonry via CSS columns for variable-height items.
    - 2 columns on small devices
    - more columns as viewport grows
  */
  .gallery {
    column-count: 2;
    column-gap: 1rem;
    padding: 0.25rem;
  }

  @media (min-width: 640px) {
    .gallery {
      column-count: 3;
    }
  }

  @media (min-width: 1024px) {
    .gallery {
      column-count: 4;
    }
  }

  /* Each item participates in the column layout and avoids breaking */
  .item {
    display: inline-block;
    width: 100%;
    margin: 0 0 1rem;
    break-inside: avoid;
    -webkit-column-break-inside: avoid;
    -moz-column-break-inside: avoid;
    border-radius: 8px;
    overflow: hidden;
    background-color: #f6f6f6;
    background-repeat: no-repeat;
    background-position: center;
    background-size: cover;
    box-shadow: 0 1px 4px rgba(0, 0, 0, 0.04);

    /* entrance */
    opacity: 0;
    transform: translateY(10px);
    transition:
      opacity 480ms ease,
      transform 480ms ease;
  }

  .item.bg-loaded {
    opacity: 1;
    transform: translateY(0);
  }

  /* Predefined height variations to improve the masonry feel */
  .h-0 {
    height: 200px;
  }
  .h-1 {
    height: 300px;
  }
  .h-2 {
    height: 240px;
  }
  .h-3 {
    height: 360px;
  }
  .h-4 {
    height: 280px;
  }

  /* Scale heights up on larger viewports */
  @media (min-width: 640px) {
    .h-0 {
      height: 260px;
    }
    .h-1 {
      height: 360px;
    }
    .h-2 {
      height: 300px;
    }
    .h-3 {
      height: 420px;
    }
    .h-4 {
      height: 340px;
    }
  }

  /* small sr-only helper for accessibility */
  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }

  /* Make nav sticky for this page only */
  nav {
    position: sticky;
    top: 0;
    z-index: 1000;
    background: var(--page-bg, #fff);
    box-shadow: 0 1px 6px rgba(0, 0, 0, 0.06);
  }
</style>

<script>
  (function () {
    const items = Array.from(document.querySelectorAll(".gallery .item"));
    if (!items.length) return;

    function loadBackground(item) {
      const src = item.dataset.src;
      if (!src) return;
      // don't load twice
      if (
        item.classList.contains("bg-loading") ||
        item.classList.contains("bg-loaded")
      )
        return;
      item.classList.add("bg-loading");
      const img = new Image();
      img.src = src;
      img.onload = () => {
        item.style.backgroundImage = `url("${src}")`;
        item.classList.remove("bg-loading");
        item.classList.add("bg-loaded");
      };
      img.onerror = () => {
        item.classList.remove("bg-loading");
        // keep placeholder background-color
      };
    }

    if ("IntersectionObserver" in window) {
      const io = new IntersectionObserver(
        (entries, observer) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              loadBackground(entry.target);
              observer.unobserve(entry.target);
            }
          });
        },
        { rootMargin: "300px" }
      );

      items.forEach((item) => io.observe(item));
    } else {
      // fallback: load all
      items.forEach(loadBackground);
    }
  })();
</script>
